<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>rok4.Storage API documentation</title>
<meta name="description" content="Provide functions to use read or write …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rok4.Storage</code></h1>
</header>
<section id="section-intro">
<p>Provide functions to use read or write</p>
<p>Available storage types are :
- S3 (path are preffixed with <code>s3://</code>)
- CEPH (path are preffixed with <code>ceph://</code>)
- FILE (path are preffixed with <code>file://</code>, but it is the default paths' interpretation)</p>
<p>According to functions, all storage types are not necessarily available.</p>
<p>Using S3 storage requires environment variables :
- ROK4_S3_KEY
- ROK4_S3_SECRETKEY
- ROK4_S3_URL</p>
<p>Using S3 storage requires environment variables :
- ROK4_CEPH_CONFFILE
- ROK4_CEPH_USERNAME
- ROK4_CEPH_CLUSTERNAME</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provide functions to use read or write

Available storage types are :
- S3 (path are preffixed with `s3://`)
- CEPH (path are preffixed with `ceph://`)
- FILE (path are preffixed with `file://`, but it is the default paths&#39; interpretation)

According to functions, all storage types are not necessarily available.

Using S3 storage requires environment variables :
- ROK4_S3_KEY
- ROK4_S3_SECRETKEY
- ROK4_S3_URL

Using S3 storage requires environment variables :
- ROK4_CEPH_CONFFILE
- ROK4_CEPH_USERNAME
- ROK4_CEPH_CLUSTERNAME
&#34;&#34;&#34;

import boto3
from boto3.s3.transfer import TransferConfig
config = TransferConfig(multipart_chunksize=65536)
import tempfile
import re
import os
import rados
import hashlib
from typing import Dict, List, Tuple
from enum import Enum
from shutil import copyfile

from rok4.Exceptions import *

class StorageType(Enum):
    FILE = &#34;file://&#34;
    S3 = &#34;s3://&#34;
    CEPH = &#34;ceph://&#34;

__S3_CLIENT = None
def __get_s3_client() -&gt; &#39;boto3.client&#39;:
    &#34;&#34;&#34;Get the S3 client

    Create it if not already done

    Raises:
        MissingEnvironmentError: Missing S3 storage informations
        StorageError: S3 client configuration issue

    Returns:
        boto3.client: S3 client
    &#34;&#34;&#34;    
    global __S3_CLIENT

    if __S3_CLIENT is None:
        try:
            s3_client = boto3.client(
                &#39;s3&#39;,
                aws_access_key_id = os.environ[&#34;ROK4_S3_KEY&#34;],
                aws_secret_access_key = os.environ[&#34;ROK4_S3_SECRETKEY&#34;],
                endpoint_url = os.environ[&#34;ROK4_S3_URL&#34;]
            )
        except KeyError as e:
            raise MissingEnvironmentError(e)
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)
    
    return s3_client

__CEPH_CLIENT = None
__CEPH_IOCTXS = dict()
def __get_ceph_ioctx(pool: str) -&gt; &#39;rados.Ioctx&#39;:
    &#34;&#34;&#34;Get the CEPH IO context

    Create it (client and context) if not already done

    Args:
        pool (str): CEPH pool&#39;s name

    Raises:
        MissingEnvironmentError: Missing CEPH storage informations
        StorageError: CEPH IO context configuration issue

    Returns:
        rados.Ioctx: IO ceph context
    &#34;&#34;&#34;    
    global __CEPH_CLIENT, __CEPH_IOCTXS

    if __CEPH_CLIENT is None:
        try:
            __CEPH_CLIENT = rados.Rados(
                conffile = os.environ[&#34;ROK4_CEPH_CONFFILE&#34;],
                clustername = os.environ[&#34;ROK4_CEPH_CLUSTERNAME&#34;],
                name = os.environ[&#34;ROK4_CEPH_USERNAME&#34;]
            )

            __CEPH_CLIENT.connect()
            
        except KeyError as e:
            raise MissingEnvironmentError(e)
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    if pool not in __CEPH_IOCTXS:
        try:
            __CEPH_IOCTXS[pool] = __CEPH_CLIENT.open_ioctx(pool)
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)
    
    return __CEPH_IOCTXS[pool]

__OBJECT_SYMLINK_SIGNATURE = &#34;SYMLINK#&#34;

def get_infos_from_path(path: str) -&gt; Tuple[StorageType, str, str, str]:
    &#34;&#34;&#34;Extract storage type, the unprefixed path, the container and the basename from path (Default: FILE storage)

    For a FILE storage, the tray is the directory and the basename is the file name.
    
    For an object storage (CEPH or S3), the tray is the bucket or the pool and the basename is the object name.

    Args:
        path (str): path to analyse

    Returns:
        Tuple[StorageType, str]: storage type and cleaned path (storage prefix removed)
    &#34;&#34;&#34;

    if path.startswith(&#34;s3://&#34;):
        bucket_name, object_name = path[5:].split(&#34;/&#34;, 1)
        return StorageType.S3, path[5:], bucket_name, object_name
    elif path.startswith(&#34;ceph://&#34;):
        pool_name, object_name = path[7:].split(&#34;/&#34;, 1)
        return StorageType.CEPH, path[7:], pool_name, object_name
    elif path.startswith(&#34;file://&#34;):
        return StorageType.FILE, path[7:], os.path.dirname(path[7:]), os.path.basename(path[7:])
    else:
        return StorageType.FILE, path, os.path.dirname(path), os.path.basename(path)


#def get_path_from_infos(storage_type: StorageType, tray: str, base_name: str) -&gt; str:
def get_path_from_infos(storage_type: StorageType, *args) -&gt; str:
    return f&#34;{storage_type.value}{os.path.join(*args)}&#34;


def hash_file(path: str) -&gt; str:
    &#34;&#34;&#34;Process MD5 sum of the provided file

    Args:
        path (str): path to file

    Returns:
        str: hexadeimal MD5 sum
    &#34;&#34;&#34;

    checker = hashlib.md5()

    with open(path,&#39;rb&#39;) as file:
        chunk = 0
        while chunk != b&#39;&#39;:
            chunk = file.read(65536)
            checker.update(chunk)

    return checker.hexdigest()

def get_data_str(path: str) -&gt; str:
    &#34;&#34;&#34;Load data into a string

    Args:
        path (str): path to data

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage read issue

    Returns:
        str: Data content
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            with tempfile.NamedTemporaryFile(&#34;w+b&#34;) as f:
                s3_client.download_fileobj(tray_name, base_name, f)
                f.seek(0)
                data = f.read().decode(&#39;utf-8&#39;)
                f.close()
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:
        
        ioctx = __get_ceph_ioctx(tray_name)

        try:
            size, mtime = ioctx.stat(base_name)
            data = ioctx.read(base_name, size).decode(&#39;utf-8&#39;)
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            f = open(path)
            data = f.read()
            f.close()
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to read string data&#34;)

    return data


def put_data_str(data: str, path: str) -&gt; None:
    &#34;&#34;&#34;Store string data into a file or an object

    UTF-8 encoding is used for bytes conversion

    Args:
        data (str): data to write
        path (str): destination path, where to write data

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage write issue
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            s3_client.put_object(
                Body = data.encode(&#39;utf-8&#39;),
                Bucket = tray_name,
                Key = base_name
            )
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:
        
        ioctx = __get_ceph_ioctx(tray_name)

        try:
            ioctx.write_full(base_name, data.encode(&#39;utf-8&#39;))
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            f = open(path, &#39;w&#39;)
            f.write(data)
            f.close()
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to write string data&#34;)


def get_size(path: str) -&gt; int:
    &#34;&#34;&#34;Get size of file or object

    Args:
        path (str): path of file/object whom size is asked

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage read issue

    Returns:
        int: file/object size, in bytes
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            size = s3_client.head_object(Bucket=tray_name, Key=base_name)[&#34;ContentLength&#34;].strip(&#39;&#34;&#39;)
            return size
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:

        ioctx = __get_ceph_ioctx(tray_name)

        try:
            size, mtime = ioctx.stat(base_name)
            return size
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            file_stats = os.stat(path)
            return file_stats.st_size
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to get size&#34;)


def remove(path: str) -&gt; None:
    &#34;&#34;&#34;Remove the file/object

    Args:
        path (str): path of file/object to remove

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage removal issue
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            s3_client.delete_object(
                Bucket=tray_name,
                Key=base_name
            )
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:

        ioctx = __get_ceph_ioctx(tray_name)

        try:
            ioctx.remove_object(base_name)
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            os.remove(path)
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to remove things&#34;)

def copy(from_path: str, to_path: str, from_md5: str = None) -&gt; None:
    &#34;&#34;&#34;Copy a file or object to a file or object place. If MD5 sum is provided, it is compared to sum after the copy.

    Args:
        from_path (str): source file/object path, to copy
        to_path (str): destination file/object path
        from_md5 (str, optional): MD5 sum, re-processed after copy and controlled. Defaults to None.

    Raises:
        StorageError: Unhandled copy or copy issue
        MissingEnvironmentError: Missing object storage informations
    &#34;&#34;&#34;

    from_type, from_path, from_tray, from_base_name  = get_infos_from_path(from_path)
    to_type, to_path, to_tray, to_base_name  = get_infos_from_path(to_path)

    # Réalisation de la copie, selon les types de stockage
    if from_type == StorageType.FILE and to_type == StorageType.FILE :
        
        try:
            if to_tray != &#34;&#34;:
                os.makedirs(to_tray, exist_ok=True)

            copyfile(from_path, to_path)

            if from_md5 is not None :
                to_md5 = hash_file(to_path)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;FILE&#34;, f&#34;Invalid MD5 sum control for copy file {from_path} to {to_path} : {from_md5} != {to_md5}&#34;)

        except Exception as e:
            raise StorageError(f&#34;FILE&#34;, f&#34;Cannot copy file {from_path} to {to_path} : {e}&#34;)

    elif from_type == StorageType.S3 and to_type == StorageType.FILE :

        s3_client = __get_s3_client()

        try:
            if to_tray != &#34;&#34;:
                os.makedirs(to_tray, exist_ok=True)

            s3_client.download_file(from_tray, from_base_name, to_path)

            if from_md5 is not None :
                to_md5 = hash_file(to_path)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;S3 and FILE&#34;, f&#34;Invalid MD5 sum control for copy S3 object {from_path} to file {to_path} : {from_md5} != {to_md5}&#34;)

        except Exception as e:
            raise StorageError(f&#34;S3 and FILE&#34;, f&#34;Cannot copy S3 object {from_path} to file {to_path} : {e}&#34;)

    elif from_type == StorageType.FILE and to_type == StorageType.S3 :

        s3_client = __get_s3_client()
        
        try:
            s3_client.upload_file(from_path, to_tray, to_base_name, Config=config)

            if from_md5 is not None :
                to_md5 = s3_client.head_object(Bucket=to_bucket, Key=to_object)[&#34;ETag&#34;].strip(&#39;&#34;&#39;)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;FILE and S3&#34;, f&#34;Invalid MD5 sum control for copy file {from_path} to S3 object {to_path} : {from_md5} != {to_md5}&#34;)
        except Exception as e:
            raise StorageError(f&#34;FILE and S3&#34;, f&#34;Cannot copy file {from_path} to S3 object {to_path} : {e}&#34;)

    elif from_type == StorageType.S3 and to_type == StorageType.S3 :

        s3_client = __get_s3_client()

        try:
            s3_client.copy(
                {
                    &#39;Bucket&#39;: from_tray,
                    &#39;Key&#39;: from_base_name
                }, 
                to_tray, to_base_name
            )

            if from_md5 is not None :
                to_md5 = s3_client.head_object(Bucket=to_tray, Key=to_base_name)[&#34;ETag&#34;].strip(&#39;&#34;&#39;)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;S3&#34;, f&#34;Invalid MD5 sum control for copy S3 object {from_path} to {to_path} : {from_md5} != {to_md5}&#34;)
        except Exception as e:
            raise StorageError(f&#34;S3&#34;, f&#34;Cannot copy S3 object {from_path} to {to_path} : {e}&#34;)
        

    elif from_type == StorageType.CEPH and to_type == StorageType.FILE :

        ioctx = __get_ceph_ioctx(from_tray)

        if from_md5 is not None:
            checker = hashlib.md5()

        try:

            if to_tray != &#34;&#34;:
                os.makedirs(to_tray, exist_ok=True)
            f = open(to_path, &#39;wb&#39;)

            offset = 0
            size = 0

            while True:
                chunk = ioctx.read(from_base_name, 65536, offset)
                size = len(chunk)
                offset += size
                f.write(chunk)

                if from_md5 is not None:
                    checker.update(chunk)

                if size &lt; 65536:
                    break

            f.close()

            if from_md5 is not None and from_md5 != checker.hexdigest():
                raise StorageError(f&#34;CEPH and FILE&#34;, f&#34;Invalid MD5 sum control for copy CEPH object {from_path} to file {to_path} : {from_md5} != {checker.hexdigest()}&#34;)

        except Exception as e:
            raise StorageError(f&#34;CEPH and FILE&#34;, f&#34;Cannot copy CEPH object {from_path} to file {to_path} : {e}&#34;)


    elif from_type == StorageType.FILE and to_type == StorageType.CEPH :

        ioctx = __get_ceph_ioctx(to_tray)
        
        if from_md5 is not None:
            checker = hashlib.md5()

        try:
            f = open(from_path, &#39;rb&#39;)

            offset = 0
            size = 0

            while True:

                chunk = f.read(65536)
                size = len(chunk)
                ioctx.write(to_base_name, chunk, offset)
                offset += size

                if from_md5 is not None:
                    checker.update(chunk)

                if size &lt; 65536:
                    break

            f.close()

            if from_md5 is not None and from_md5 != checker.hexdigest():
                raise StorageError(f&#34;FILE and CEPH&#34;, f&#34;Invalid MD5 sum control for copy file {from_path} to CEPH object {to_path} : {from_md5} != {checker.hexdigest()}&#34;)

        except Exception as e:
            raise StorageError(f&#34;FILE and CEPH&#34;, f&#34;Cannot copy file {from_path} to CEPH object {to_path} : {e}&#34;)


    elif from_type == StorageType.CEPH and to_type == StorageType.CEPH :

        from_ioctx = __get_ceph_ioctx(from_tray)
        to_ioctx = __get_ceph_ioctx(to_tray)

        if from_md5 is not None:
            checker = hashlib.md5()

        try:

            offset = 0
            size = 0

            while True:
                chunk = from_ioctx.read(from_base_name, 65536, offset)
                size = len(chunk)
                to_ioctx.write(to_base_name, chunk, offset)
                offset += size

                if md5 is not None:
                    checker.update(chunk)

                if size &lt; 65536:
                    break

            if md5 is not None and md5 != checker.hexdigest():
                raise StorageError(f&#34;FILE and CEPH&#34;, f&#34;Invalid MD5 sum control for copy CEPH object {from_path} to {to_path} : {md5} != {checker.hexdigest()}&#34;)

        except Exception as e:
            raise StorageError(f&#34;CEPH&#34;, f&#34;Cannot copy CEPH object {from_path} to {to_path} : {e}&#34;)


    else:
        raise StorageError(f&#34;{from_type.name} and {to_type.name}&#34;, f&#34;Cannot copy from {from_type.name} to {to_type.name}&#34;)



def link(target_path: str, link_path: str, hard: bool = False) -&gt; None:
    &#34;&#34;&#34;Create a symbolic link

    Args:
        target_path (str): file/object to link
        link_path (str): link to create
        hard (bool, optional): hard link rather than symbolic. Only for FILE storage. Defaults to False.

    Raises:
        StorageError: Unhandled link or link issue
        MissingEnvironmentError: Missing object storage informations
    &#34;&#34;&#34;

    target_type, target_path, target_tray, target_base_name  = get_infos_from_path(target_path)
    link_type, link_path, link_tray, link_base_name  = get_infos_from_path(link_path)

    if target_type != link_type:
        raise StorageError(f&#34;{target_type.name} and {link_type.name}&#34;, f&#34;Cannot make link between two different storage types&#34;)

    if hard and target_type != StorageType.FILE:
        raise StorageError(target_type.name, &#34;Hard link is available only for FILE storage&#34;)

    # Réalisation du lien, selon les types de stockage
    if target_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            s3_client.put_object(
                Body = f&#34;{__OBJECT_SYMLINK_SIGNATURE}{target_path}&#34;.encode(&#39;utf-8&#39;),
                Bucket = link_tray,
                Key = link_base_name
            )
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif target_type == StorageType.CEPH:
        
        ioctx = __get_ceph_ioctx(link_tray)

        try:
            ioctx.write_full(link_base_name, f&#34;{__OBJECT_SYMLINK_SIGNATURE}{target_path}&#34;.encode(&#39;utf-8&#39;))
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif target_type == StorageType.FILE:

        try:
            if hard:
                os.link(target_path, link_path)
            else:
                os.symlink(target_path, link_path)
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to make link&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="rok4.Storage.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>from_path: str, to_path: str, from_md5: str = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a file or object to a file or object place. If MD5 sum is provided, it is compared to sum after the copy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_path</code></strong> :&ensp;<code>str</code></dt>
<dd>source file/object path, to copy</dd>
<dt><strong><code>to_path</code></strong> :&ensp;<code>str</code></dt>
<dd>destination file/object path</dd>
<dt><strong><code>from_md5</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>MD5 sum, re-processed after copy and controlled. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StorageError</code></dt>
<dd>Unhandled copy or copy issue</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(from_path: str, to_path: str, from_md5: str = None) -&gt; None:
    &#34;&#34;&#34;Copy a file or object to a file or object place. If MD5 sum is provided, it is compared to sum after the copy.

    Args:
        from_path (str): source file/object path, to copy
        to_path (str): destination file/object path
        from_md5 (str, optional): MD5 sum, re-processed after copy and controlled. Defaults to None.

    Raises:
        StorageError: Unhandled copy or copy issue
        MissingEnvironmentError: Missing object storage informations
    &#34;&#34;&#34;

    from_type, from_path, from_tray, from_base_name  = get_infos_from_path(from_path)
    to_type, to_path, to_tray, to_base_name  = get_infos_from_path(to_path)

    # Réalisation de la copie, selon les types de stockage
    if from_type == StorageType.FILE and to_type == StorageType.FILE :
        
        try:
            if to_tray != &#34;&#34;:
                os.makedirs(to_tray, exist_ok=True)

            copyfile(from_path, to_path)

            if from_md5 is not None :
                to_md5 = hash_file(to_path)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;FILE&#34;, f&#34;Invalid MD5 sum control for copy file {from_path} to {to_path} : {from_md5} != {to_md5}&#34;)

        except Exception as e:
            raise StorageError(f&#34;FILE&#34;, f&#34;Cannot copy file {from_path} to {to_path} : {e}&#34;)

    elif from_type == StorageType.S3 and to_type == StorageType.FILE :

        s3_client = __get_s3_client()

        try:
            if to_tray != &#34;&#34;:
                os.makedirs(to_tray, exist_ok=True)

            s3_client.download_file(from_tray, from_base_name, to_path)

            if from_md5 is not None :
                to_md5 = hash_file(to_path)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;S3 and FILE&#34;, f&#34;Invalid MD5 sum control for copy S3 object {from_path} to file {to_path} : {from_md5} != {to_md5}&#34;)

        except Exception as e:
            raise StorageError(f&#34;S3 and FILE&#34;, f&#34;Cannot copy S3 object {from_path} to file {to_path} : {e}&#34;)

    elif from_type == StorageType.FILE and to_type == StorageType.S3 :

        s3_client = __get_s3_client()
        
        try:
            s3_client.upload_file(from_path, to_tray, to_base_name, Config=config)

            if from_md5 is not None :
                to_md5 = s3_client.head_object(Bucket=to_bucket, Key=to_object)[&#34;ETag&#34;].strip(&#39;&#34;&#39;)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;FILE and S3&#34;, f&#34;Invalid MD5 sum control for copy file {from_path} to S3 object {to_path} : {from_md5} != {to_md5}&#34;)
        except Exception as e:
            raise StorageError(f&#34;FILE and S3&#34;, f&#34;Cannot copy file {from_path} to S3 object {to_path} : {e}&#34;)

    elif from_type == StorageType.S3 and to_type == StorageType.S3 :

        s3_client = __get_s3_client()

        try:
            s3_client.copy(
                {
                    &#39;Bucket&#39;: from_tray,
                    &#39;Key&#39;: from_base_name
                }, 
                to_tray, to_base_name
            )

            if from_md5 is not None :
                to_md5 = s3_client.head_object(Bucket=to_tray, Key=to_base_name)[&#34;ETag&#34;].strip(&#39;&#34;&#39;)
                if to_md5 != from_md5:
                    raise StorageError(f&#34;S3&#34;, f&#34;Invalid MD5 sum control for copy S3 object {from_path} to {to_path} : {from_md5} != {to_md5}&#34;)
        except Exception as e:
            raise StorageError(f&#34;S3&#34;, f&#34;Cannot copy S3 object {from_path} to {to_path} : {e}&#34;)
        

    elif from_type == StorageType.CEPH and to_type == StorageType.FILE :

        ioctx = __get_ceph_ioctx(from_tray)

        if from_md5 is not None:
            checker = hashlib.md5()

        try:

            if to_tray != &#34;&#34;:
                os.makedirs(to_tray, exist_ok=True)
            f = open(to_path, &#39;wb&#39;)

            offset = 0
            size = 0

            while True:
                chunk = ioctx.read(from_base_name, 65536, offset)
                size = len(chunk)
                offset += size
                f.write(chunk)

                if from_md5 is not None:
                    checker.update(chunk)

                if size &lt; 65536:
                    break

            f.close()

            if from_md5 is not None and from_md5 != checker.hexdigest():
                raise StorageError(f&#34;CEPH and FILE&#34;, f&#34;Invalid MD5 sum control for copy CEPH object {from_path} to file {to_path} : {from_md5} != {checker.hexdigest()}&#34;)

        except Exception as e:
            raise StorageError(f&#34;CEPH and FILE&#34;, f&#34;Cannot copy CEPH object {from_path} to file {to_path} : {e}&#34;)


    elif from_type == StorageType.FILE and to_type == StorageType.CEPH :

        ioctx = __get_ceph_ioctx(to_tray)
        
        if from_md5 is not None:
            checker = hashlib.md5()

        try:
            f = open(from_path, &#39;rb&#39;)

            offset = 0
            size = 0

            while True:

                chunk = f.read(65536)
                size = len(chunk)
                ioctx.write(to_base_name, chunk, offset)
                offset += size

                if from_md5 is not None:
                    checker.update(chunk)

                if size &lt; 65536:
                    break

            f.close()

            if from_md5 is not None and from_md5 != checker.hexdigest():
                raise StorageError(f&#34;FILE and CEPH&#34;, f&#34;Invalid MD5 sum control for copy file {from_path} to CEPH object {to_path} : {from_md5} != {checker.hexdigest()}&#34;)

        except Exception as e:
            raise StorageError(f&#34;FILE and CEPH&#34;, f&#34;Cannot copy file {from_path} to CEPH object {to_path} : {e}&#34;)


    elif from_type == StorageType.CEPH and to_type == StorageType.CEPH :

        from_ioctx = __get_ceph_ioctx(from_tray)
        to_ioctx = __get_ceph_ioctx(to_tray)

        if from_md5 is not None:
            checker = hashlib.md5()

        try:

            offset = 0
            size = 0

            while True:
                chunk = from_ioctx.read(from_base_name, 65536, offset)
                size = len(chunk)
                to_ioctx.write(to_base_name, chunk, offset)
                offset += size

                if md5 is not None:
                    checker.update(chunk)

                if size &lt; 65536:
                    break

            if md5 is not None and md5 != checker.hexdigest():
                raise StorageError(f&#34;FILE and CEPH&#34;, f&#34;Invalid MD5 sum control for copy CEPH object {from_path} to {to_path} : {md5} != {checker.hexdigest()}&#34;)

        except Exception as e:
            raise StorageError(f&#34;CEPH&#34;, f&#34;Cannot copy CEPH object {from_path} to {to_path} : {e}&#34;)


    else:
        raise StorageError(f&#34;{from_type.name} and {to_type.name}&#34;, f&#34;Cannot copy from {from_type.name} to {to_type.name}&#34;)</code></pre>
</details>
</dd>
<dt id="rok4.Storage.get_data_str"><code class="name flex">
<span>def <span class="ident">get_data_str</span></span>(<span>path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Load data into a string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to data</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage read issue</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Data content</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_str(path: str) -&gt; str:
    &#34;&#34;&#34;Load data into a string

    Args:
        path (str): path to data

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage read issue

    Returns:
        str: Data content
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            with tempfile.NamedTemporaryFile(&#34;w+b&#34;) as f:
                s3_client.download_fileobj(tray_name, base_name, f)
                f.seek(0)
                data = f.read().decode(&#39;utf-8&#39;)
                f.close()
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:
        
        ioctx = __get_ceph_ioctx(tray_name)

        try:
            size, mtime = ioctx.stat(base_name)
            data = ioctx.read(base_name, size).decode(&#39;utf-8&#39;)
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            f = open(path)
            data = f.read()
            f.close()
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to read string data&#34;)

    return data</code></pre>
</details>
</dd>
<dt id="rok4.Storage.get_infos_from_path"><code class="name flex">
<span>def <span class="ident">get_infos_from_path</span></span>(<span>path: str) ‑> Tuple[<a title="rok4.Storage.StorageType" href="#rok4.Storage.StorageType">StorageType</a>, str, str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract storage type, the unprefixed path, the container and the basename from path (Default: FILE storage)</p>
<p>For a FILE storage, the tray is the directory and the basename is the file name.</p>
<p>For an object storage (CEPH or S3), the tray is the bucket or the pool and the basename is the object name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to analyse</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[<a title="rok4.Storage.StorageType" href="#rok4.Storage.StorageType">StorageType</a>, str]</code></dt>
<dd>storage type and cleaned path (storage prefix removed)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_infos_from_path(path: str) -&gt; Tuple[StorageType, str, str, str]:
    &#34;&#34;&#34;Extract storage type, the unprefixed path, the container and the basename from path (Default: FILE storage)

    For a FILE storage, the tray is the directory and the basename is the file name.
    
    For an object storage (CEPH or S3), the tray is the bucket or the pool and the basename is the object name.

    Args:
        path (str): path to analyse

    Returns:
        Tuple[StorageType, str]: storage type and cleaned path (storage prefix removed)
    &#34;&#34;&#34;

    if path.startswith(&#34;s3://&#34;):
        bucket_name, object_name = path[5:].split(&#34;/&#34;, 1)
        return StorageType.S3, path[5:], bucket_name, object_name
    elif path.startswith(&#34;ceph://&#34;):
        pool_name, object_name = path[7:].split(&#34;/&#34;, 1)
        return StorageType.CEPH, path[7:], pool_name, object_name
    elif path.startswith(&#34;file://&#34;):
        return StorageType.FILE, path[7:], os.path.dirname(path[7:]), os.path.basename(path[7:])
    else:
        return StorageType.FILE, path, os.path.dirname(path), os.path.basename(path)</code></pre>
</details>
</dd>
<dt id="rok4.Storage.get_path_from_infos"><code class="name flex">
<span>def <span class="ident">get_path_from_infos</span></span>(<span>storage_type: <a title="rok4.Storage.StorageType" href="#rok4.Storage.StorageType">StorageType</a>, *args) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_from_infos(storage_type: StorageType, *args) -&gt; str:
    return f&#34;{storage_type.value}{os.path.join(*args)}&#34;</code></pre>
</details>
</dd>
<dt id="rok4.Storage.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>path: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get size of file or object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path of file/object whom size is asked</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage read issue</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>file/object size, in bytes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(path: str) -&gt; int:
    &#34;&#34;&#34;Get size of file or object

    Args:
        path (str): path of file/object whom size is asked

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage read issue

    Returns:
        int: file/object size, in bytes
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            size = s3_client.head_object(Bucket=tray_name, Key=base_name)[&#34;ContentLength&#34;].strip(&#39;&#34;&#39;)
            return size
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:

        ioctx = __get_ceph_ioctx(tray_name)

        try:
            size, mtime = ioctx.stat(base_name)
            return size
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            file_stats = os.stat(path)
            return file_stats.st_size
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to get size&#34;)</code></pre>
</details>
</dd>
<dt id="rok4.Storage.hash_file"><code class="name flex">
<span>def <span class="ident">hash_file</span></span>(<span>path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Process MD5 sum of the provided file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>hexadeimal MD5 sum</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_file(path: str) -&gt; str:
    &#34;&#34;&#34;Process MD5 sum of the provided file

    Args:
        path (str): path to file

    Returns:
        str: hexadeimal MD5 sum
    &#34;&#34;&#34;

    checker = hashlib.md5()

    with open(path,&#39;rb&#39;) as file:
        chunk = 0
        while chunk != b&#39;&#39;:
            chunk = file.read(65536)
            checker.update(chunk)

    return checker.hexdigest()</code></pre>
</details>
</dd>
<dt id="rok4.Storage.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>target_path: str, link_path: str, hard: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a symbolic link</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_path</code></strong> :&ensp;<code>str</code></dt>
<dd>file/object to link</dd>
<dt><strong><code>link_path</code></strong> :&ensp;<code>str</code></dt>
<dd>link to create</dd>
<dt><strong><code>hard</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>hard link rather than symbolic. Only for FILE storage. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StorageError</code></dt>
<dd>Unhandled link or link issue</dd>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(target_path: str, link_path: str, hard: bool = False) -&gt; None:
    &#34;&#34;&#34;Create a symbolic link

    Args:
        target_path (str): file/object to link
        link_path (str): link to create
        hard (bool, optional): hard link rather than symbolic. Only for FILE storage. Defaults to False.

    Raises:
        StorageError: Unhandled link or link issue
        MissingEnvironmentError: Missing object storage informations
    &#34;&#34;&#34;

    target_type, target_path, target_tray, target_base_name  = get_infos_from_path(target_path)
    link_type, link_path, link_tray, link_base_name  = get_infos_from_path(link_path)

    if target_type != link_type:
        raise StorageError(f&#34;{target_type.name} and {link_type.name}&#34;, f&#34;Cannot make link between two different storage types&#34;)

    if hard and target_type != StorageType.FILE:
        raise StorageError(target_type.name, &#34;Hard link is available only for FILE storage&#34;)

    # Réalisation du lien, selon les types de stockage
    if target_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            s3_client.put_object(
                Body = f&#34;{__OBJECT_SYMLINK_SIGNATURE}{target_path}&#34;.encode(&#39;utf-8&#39;),
                Bucket = link_tray,
                Key = link_base_name
            )
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif target_type == StorageType.CEPH:
        
        ioctx = __get_ceph_ioctx(link_tray)

        try:
            ioctx.write_full(link_base_name, f&#34;{__OBJECT_SYMLINK_SIGNATURE}{target_path}&#34;.encode(&#39;utf-8&#39;))
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif target_type == StorageType.FILE:

        try:
            if hard:
                os.link(target_path, link_path)
            else:
                os.symlink(target_path, link_path)
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to make link&#34;)</code></pre>
</details>
</dd>
<dt id="rok4.Storage.put_data_str"><code class="name flex">
<span>def <span class="ident">put_data_str</span></span>(<span>data: str, path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Store string data into a file or an object</p>
<p>UTF-8 encoding is used for bytes conversion</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>data to write</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>destination path, where to write data</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage write issue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_data_str(data: str, path: str) -&gt; None:
    &#34;&#34;&#34;Store string data into a file or an object

    UTF-8 encoding is used for bytes conversion

    Args:
        data (str): data to write
        path (str): destination path, where to write data

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage write issue
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            s3_client.put_object(
                Body = data.encode(&#39;utf-8&#39;),
                Bucket = tray_name,
                Key = base_name
            )
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:
        
        ioctx = __get_ceph_ioctx(tray_name)

        try:
            ioctx.write_full(base_name, data.encode(&#39;utf-8&#39;))
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            f = open(path, &#39;w&#39;)
            f.write(data)
            f.close()
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to write string data&#34;)</code></pre>
</details>
</dd>
<dt id="rok4.Storage.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the file/object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path of file/object to remove</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>MissingEnvironmentError</code></dt>
<dd>Missing object storage informations</dd>
<dt><code>StorageError</code></dt>
<dd>Storage removal issue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(path: str) -&gt; None:
    &#34;&#34;&#34;Remove the file/object

    Args:
        path (str): path of file/object to remove

    Raises:
        MissingEnvironmentError: Missing object storage informations
        StorageError: Storage removal issue
    &#34;&#34;&#34;

    storage_type, path, tray_name, base_name  = get_infos_from_path(path)

    if storage_type == StorageType.S3:
        
        s3_client = __get_s3_client()

        try:
            s3_client.delete_object(
                Bucket=tray_name,
                Key=base_name
            )
        except Exception as e:
            raise StorageError(&#34;S3&#34;, e)

    elif storage_type == StorageType.CEPH:

        ioctx = __get_ceph_ioctx(tray_name)

        try:
            ioctx.remove_object(base_name)
        except Exception as e:
            raise StorageError(&#34;CEPH&#34;, e)

    elif storage_type == StorageType.FILE:

        try:
            os.remove(path)
        except Exception as e:
            raise StorageError(&#34;FILE&#34;, e)

    else:
        raise StorageError(&#34;UNKNOWN&#34;, &#34;Unhandled storage type to remove things&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rok4.Storage.StorageType"><code class="flex name class">
<span>class <span class="ident">StorageType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageType(Enum):
    FILE = &#34;file://&#34;
    S3 = &#34;s3://&#34;
    CEPH = &#34;ceph://&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="rok4.Storage.StorageType.CEPH"><code class="name">var <span class="ident">CEPH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rok4.Storage.StorageType.FILE"><code class="name">var <span class="ident">FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="rok4.Storage.StorageType.S3"><code class="name">var <span class="ident">S3</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rok4" href="index.html">rok4</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="rok4.Storage.copy" href="#rok4.Storage.copy">copy</a></code></li>
<li><code><a title="rok4.Storage.get_data_str" href="#rok4.Storage.get_data_str">get_data_str</a></code></li>
<li><code><a title="rok4.Storage.get_infos_from_path" href="#rok4.Storage.get_infos_from_path">get_infos_from_path</a></code></li>
<li><code><a title="rok4.Storage.get_path_from_infos" href="#rok4.Storage.get_path_from_infos">get_path_from_infos</a></code></li>
<li><code><a title="rok4.Storage.get_size" href="#rok4.Storage.get_size">get_size</a></code></li>
<li><code><a title="rok4.Storage.hash_file" href="#rok4.Storage.hash_file">hash_file</a></code></li>
<li><code><a title="rok4.Storage.link" href="#rok4.Storage.link">link</a></code></li>
<li><code><a title="rok4.Storage.put_data_str" href="#rok4.Storage.put_data_str">put_data_str</a></code></li>
<li><code><a title="rok4.Storage.remove" href="#rok4.Storage.remove">remove</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rok4.Storage.StorageType" href="#rok4.Storage.StorageType">StorageType</a></code></h4>
<ul class="">
<li><code><a title="rok4.Storage.StorageType.CEPH" href="#rok4.Storage.StorageType.CEPH">CEPH</a></code></li>
<li><code><a title="rok4.Storage.StorageType.FILE" href="#rok4.Storage.StorageType.FILE">FILE</a></code></li>
<li><code><a title="rok4.Storage.StorageType.S3" href="#rok4.Storage.StorageType.S3">S3</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>